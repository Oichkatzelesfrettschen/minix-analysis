% ===============================================================================
% CHAPTER 2: MINIX 3.4 FUNDAMENTALS
% Microkernel Architecture, Process Models, and Communication
% ===============================================================================

\chapter{MINIX 3.4 Fundamentals}
\label{ch:fundamentals}

\section{Overview}

\minix{} 3.4 is a modern microkernel operating system designed for educational purposes, reliability research, and embedded systems applications. This chapter introduces the fundamental architectural concepts and design principles that distinguish \minix{} from monolithic operating systems like \linux{}.

\keyinsight{
MINIX 3.4 implements a microkernel architecture where the kernel provides minimal core functionality (process management, message passing, interrupt handling), while all other OS services (file systems, device drivers, networking) run as unprivileged user-space processes. This design enhances modularity, reliability, and security.
}

\section{Microkernel Architecture}

\subsection{Core Design Principles}

\minix{}'s microkernel design is built on several core principles:

\begin{enumerate}
\item \textbf{Minimal Kernel:} The kernel (approximately 95 KB) provides only essential services:
  \begin{itemize}
  \item Process and thread management
  \item Interrupt and exception handling
  \item Low-level message passing (IPC)
  \item Virtual memory management
  \end{itemize}

\item \textbf{Privilege Separation:} OS services run as unprivileged processes, enabling:
  \begin{itemize}
  \item Fault isolation (crash of one service doesn't crash system)
  \item Clear security boundaries
  \item Easier testing and debugging
  \item Fine-grained access control
  \end{itemize}

\item \textbf{Message-Based Communication:} All inter-process communication uses synchronous message passing:
  \begin{itemize}
  \item Process A sends message to Process B
  \item Process A blocks until reply received
  \item No shared memory for IPC (unless explicitly shared)
  \item Transparent location independence
  \end{itemize}

\item \textbf{Modularity:} Each system service is independent:
  \begin{itemize}
  \item Services can be restarted without affecting others
  \item Services can be replaced or upgraded
  \item Services can run on different machines (distributed systems)
  \item Clear, well-defined interfaces
  \end{itemize}
\end{enumerate}

\section{Process Model}

MINIX processes are organized by privilege level:

\begin{description}
\item[Kernel:] Minimal core functionality with full hardware access
\item[Servers:] System services (file system, drivers) with limited privilege
\item[Drivers:] Device drivers communicating via message passing
\item[User Programs:] Unprivileged applications using system calls
\end{description}

\section{Communication Model}

All inter-process communication uses synchronous message passing:

\begin{enumerate}
\item Sender sends message and blocks
\item Receiver processes message
\item Receiver sends reply
\item Sender resumes with reply
\end{enumerate}

\keyinsight{
The synchronous message passing model ensures simple, predictable communication patterns and prevents complex race conditions inherent in shared-memory systems.}

This communication model is illustrated in Figure~\ref{fig:ipc-sequence}, which shows the message exchange timeline between two processes.

\begin{figure}[!htbp]
\centering
\begin{tikzpicture}[scale=1.0]
    % Time axis
    \draw[thick, minixdark] (0, 0) -- (0, 8);
    \node[anchor=east, font=\footnotesize] at (-0.3, 0) {Time};

    % Process A timeline
    \draw[very thick, accentblue] (1, 0) -- (1, 8);
    \node[anchor=south, font=\small\bfseries, color=accentblue] at (1, 8.3) {Process A (Sender)};

    % Process B timeline
    \draw[very thick, accentgreen] (5, 0) -- (5, 8);
    \node[anchor=south, font=\small\bfseries, color=accentgreen] at (5, 8.3) {Process B (Receiver)};

    % Kernel
    \draw[very thick, accentred] (9, 0) -- (9, 8);
    \node[anchor=south, font=\small\bfseries, color=accentred] at (9, 8.3) {Kernel};

    % Events
    \node[action, anchor=west] at (1.5, 7) {1. Call send()};
    \node[action, anchor=west] at (1.5, 6.2) {(blocks)};

    \draw[thick, arrow] (1, 6) -- (9, 5.5);
    \node[anchor=south, font=\tiny, fill=white] at (5, 5.8) {SEND syscall};

    \node[action, anchor=west] at (8.5, 5) {Queue message};

    \draw[thick, arrow] (9, 4.8) -- (5, 4.3);
    \node[anchor=south, font=\tiny, fill=white] at (7, 4.6) {Wakeup};

    \node[action, anchor=west] at (5.5, 4) {2. receive()\\gets message};

    \node[action, anchor=west] at (5.5, 2.8) {3. Process\\message};

    \node[action, anchor=west] at (5.5, 1.8) {4. send reply()};

    \draw[thick, returnarrow] (5, 1.5) -- (1, 1);
    \node[anchor=south, font=\tiny, fill=white] at (3, 1.3) {REPLY syscall};

    \node[action, anchor=west] at (1.5, 0.5) {5. Resume\\with reply};

    % Highlight blocking periods
    \draw[minixblue, fill=minixblue, opacity=0.1] (0.7, 6) rectangle (1.3, 1);
\end{tikzpicture}
\caption{Synchronous Message Passing Sequence. Process A sends a message and blocks until receiving a reply from Process B. The kernel mediates all communication, ensuring isolation and proper ordering.}
\label{fig:ipc-sequence}
\end{figure}

\section{Memory Layout and x86 Architecture}

\minix{} 3.4 runs on 32-bit x86 architecture (i386 and compatible processors). The memory layout and address space organization are critical for understanding system operation.

\begin{figure}[!htbp]
\centering
\begin{tikzpicture}[scale=1.0]
    % Memory address space (left side)
    \draw[thick, minixdark] (0, 0) rectangle (1.5, 10);
    \node[anchor=east, font=\footnotesize\bfseries] at (-0.2, 10.5) {Virtual Address Space};

    % Kernel space (high addresses)
    \node[kernel, minimum height=1.5cm, minimum width=1.2cm] (kernel) at (0.75, 8.5) {Kernel\\(95 KB)};
    \draw[thick, minixdark] (0, 8) to (1.5, 8);
    \node[anchor=west, font=\footnotesize] at (1.7, 8) {0xFFFF0000};

    % IO space
    \node[hardware, minimum height=1cm, minimum width=1.2cm] (io) at (0.75, 6.75) {I/O\\Maps};
    \draw[thick, minixdark] (0, 6.5) to (1.5, 6.5);
    \node[anchor=west, font=\footnotesize] at (1.7, 6.5) {0xC0000000};

    % Process space (heap, stack, segments)
    \node[userspace, minimum height=3cm, minimum width=1.2cm] at (0.75, 3.5) {Process\\Address\\Space};
    \draw[thick, minixdark] (0, 2) to (1.5, 2);
    \node[anchor=west, font=\footnotesize] at (1.7, 2) {Heap/Data};

    \draw[thick, minixdark] (0, 0.5) to (1.5, 0.5);
    \node[anchor=west, font=\footnotesize] at (1.7, 0.5) {0x08048000};

    \node[anchor=west, font=\footnotesize] at (1.7, 0) {Stack (grows down)};

    % CPU state registers (right side)
    \draw[thick, minixdark] (3.5, 8) rectangle (7, 10);
    \node[anchor=north, font=\small\bfseries] at (5.25, 10.2) {CPU Registers};

    \node[memory] at (4, 9.4) {EAX};
    \node[memory] at (5.25, 9.4) {EBX};
    \node[memory] at (6.5, 9.4) {ECX};
    \node[memory] at (4, 8.8) {EDX};
    \node[memory] at (5.25, 8.8) {ESP};
    \node[memory] at (6.5, 8.8) {EIP};

    % Control registers
    \draw[thick, minixdark] (3.5, 6) rectangle (7, 7.5);
    \node[anchor=north, font=\small\bfseries] at (5.25, 7.7) {Control Registers};

    \node[memory] at (4, 7.1) {CR0 (Paging)};
    \node[memory] at (5.25, 7.1) {CR2 (Faults)};
    \node[memory] at (6.5, 7.1) {CR3 (Page Table)};
    \node[memory] at (4.75, 6.5) {EFLAGS};

    % Tables
    \draw[thick, minixdark] (3.5, 3.5) rectangle (7, 5);
    \node[anchor=north, font=\small\bfseries] at (5.25, 5.2) {Memory Management Tables};

    \node[data] at (4.2, 4.5) {GDT};
    \node[data] at (5.25, 4.5) {IDT};
    \node[data] at (6.3, 4.5) {Page Tables};
    \node[data] at (4.75, 3.9) {TSS};

\end{tikzpicture}
\caption{x86 Memory Layout and CPU State. Virtual address space shows kernel at high addresses (0xFFFF0000+), I/O mappings, and process-specific regions (heap, data, stack). Critical CPU structures: general-purpose registers (EAX-EDX, ESP, EIP), control registers (CR0-CR3, EFLAGS), and memory management tables (GDT, IDT, Page Tables, TSS).}
\label{fig:memory-layout}
\end{figure}
}

\section{Memory Management}

Each process has isolated virtual address space with:

\begin{itemize}
\item Text segment (code)
\item Data segment (initialized variables)
\item BSS segment (uninitialized variables)
\item Heap (dynamic memory)
\item Stack (local variables and function calls)
\end{itemize}

The x86-64 MMU enforces memory protection through page tables and raises page faults for violations.

\section{Interrupt and Exception Handling}

Hardware interrupts and exceptions are handled through a kernel dispatcher that sends messages to appropriate drivers and services.

\section{System Call Interface}

MINIX implements POSIX-compatible system calls for:

\begin{itemize}
\item Process management (\code{fork}, \code{exec}, \code{wait})
\item File I/O (\code{open}, \code{read}, \code{write}, \code{close})
\item Memory management (\code{mmap}, \code{brk})
\item Signal handling (\code{signal}, \code{kill})
\item Synchronization primitives
\end{itemize}

System calls are converted to messages by the kernel dispatcher.

\section{Boot Sequence Overview}

MINIX boot sequence proceeds through these stages:

\begin{enumerate}
\item BIOS/Bootloader loads kernel
\item Kernel initializes memory, interrupts, process table
\item Init process starts system servers
\item File system server initialized
\item Device drivers and managers started
\item TTY driver ready for login
\item User shell launches
\end{enumerate}

\section{Advantages and Challenges}

\subsection{Advantages}

\begin{itemize}
\item \textbf{Reliability:} Fault isolation prevents cascade failures
\item \textbf{Security:} Privilege separation limits compromise impact
\item \textbf{Modularity:} Services independent and replaceable
\item \textbf{Maintainability:} Small kernel easier to understand
\item \textbf{Education:} Excellent for teaching OS concepts
\end{itemize}

\subsection{Challenges}

\begin{itemize}
\item \textbf{Performance:} Message passing overhead
\item \textbf{Complexity:} Service coordination complexity
\item \textbf{Debugging:} Distributed nature increases difficulty
\item \textbf{Optimization:} Hard to optimize across boundaries
\end{itemize}

\section{Transition to Methodology}

Having established fundamental MINIX 3.4 concepts, \cref{ch:methodology} describes the analysis methodology, tools, and techniques used to study this system in detail.

\clearpage
