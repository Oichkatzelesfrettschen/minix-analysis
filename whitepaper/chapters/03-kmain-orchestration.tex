\chapter{kmain() Orchestration: Central Boot Hub}

\section{Overview}

The \texttt{kmain()} function serves as the central orchestrator of the MINIX kernel boot sequence.
After \texttt{pre\_init()} enables paging and returns, \texttt{kmain()} takes control and orchestrates
the initialization of all kernel subsystems: process management, virtual memory, interrupts, and IPC.

This chapter traces the complete execution flow of \texttt{kmain()}, analyzing:
\begin{enumerate}
\item Direct function calls (30+ major functions invoked)
\item Process table initialization and boot process setup
\item Kernel subsystem sequencing
\item Transition from boot-time code to scheduler
\end{enumerate}

\section{WHAT: Actions Performed by kmain()}

\subsection{High-Level Sequence}

Entry: \texttt{void kmain(kinfo\_t *local\_cbi)} at line 115 of main.c

\begin{enumerate}
\item \textbf{Validate BSS}: Sanity check that BSS section was properly zeroed
\item \textbf{Copy Boot Info}: Copy kinfo\_t and kmessages structures from stack to global memory
\item \textbf{Set Board ID}: Query bootloader parameters to identify hardware platform
\item \textbf{Initialize CPU}: Call cstart() for architecture-specific CPU setup (GDT, IDT, etc.)
\item \textbf{Initialize Process Table}: Call proc\_init() to prepare process array
\item \textbf{Load Boot Processes}: Iterate through boot image, set up each process structure
\item \textbf{Set Process Privileges}: Assign security privileges and IPC capabilities
\item \textbf{Initialize Memory System}: Call memory\_init() for paging and VM management
\item \textbf{Initialize System}: Call system\_init() for exception handlers and system tables
\item \textbf{Transition to Scheduler}: Install timer interrupt and begin scheduling
\end{enumerate}

\section{WHEN: Boot Timeline and Execution Order}

\begin{table}[h!]
\centering
\caption{kmain() Execution Phases and Typical Durations}
\begin{tabular}{lrrr}
\toprule
Phase & Function & Duration & Cumulative \\
\midrule
Entry validation & (assertions, BSS check) & 0.5ms & 152.6ms \\
Parameter copying & memcpy(&kinfo) & 0.1ms & 152.7ms \\
CPU setup & cstart() & 10-20ms & 162.7-172.7ms \\
Process table & proc\_init() & 1ms & 163.7-173.7ms \\
Boot process loop & (initialize 12-15 tasks) & 5-10ms & 168.7-183.7ms \\
Memory system & memory\_init() & 15-25ms & 183.7-208.7ms \\
System init & system\_init() & 5-10ms & 188.7-218.7ms \\
Scheduler setup & install\_timer() & 1ms & 189.7-219.7ms \\
\bottomrule
\end{tabular}
\end{table}

\what{The entire kmain() execution, from BSS check to scheduler startup, typically takes
35-65 milliseconds. On a fast system (e.g., modern multi-core CPU with high clock rate),
this can be as short as 20-30ms. On slower embedded systems, it may extend to 80-100ms.}

\section{WHY: Architectural Decisions}

\subsection{Hub-and-Spoke Topology}

The MINIX boot architecture uses a hub-and-spoke pattern, with \texttt{kmain()} as the hub:

\begin{itemize}
\item \texttt{Hub} (kmain): Central orchestrator, calls each subsystem in sequence
\item \texttt{Spokes} (subsystem init functions): cstart, proc\_init, memory\_init, etc.
\item \textbf{Advantage}: Clear initialization order, easy to reason about dependencies
\item \textbf{Disadvantage}: Tight coupling between initialization phases
\end{itemize}

\why{The hub-and-spoke design simplifies debugging: if the kernel fails to boot,
examining the kmain() source immediately shows which initialization phase was executing.
A graph-based or dependency-driven model would be more flexible but harder to debug.}

\subsection{Process Initialization Before Memory System}

Note the sequence: process table is initialized (proc\_init) BEFORE memory management
(memory\_init). This is intentional:

\begin{itemize}
\item \textbf{Phase 1}: Process structures allocated in kernel BSS (pre-allocated, no dynamic memory)
\item \textbf{Phase 2}: Memory system takes over; processes can now request pages
\item \textbf{Phase 3}: Memory system (VM server) becomes a process with full privileges
\end{itemize}

\why{This ordering avoids a chicken-and-egg problem: the memory system needs a process
structure to run, but the memory allocator might depend on process context. By pre-allocating
process structures in BSS, kmain() can initialize the memory system as a process.}

\section{HOW: Instruction-Level Execution}

\subsection{Source Code: main.c (Lines 115-281)}

The complete kmain() orchestration (select portions):

\begin{lstlisting}[style=cstyle,caption={kmain() Main Orchestration Loop}]
void kmain(kinfo_t *local_cbi)
{
  struct boot_image *ip;
  register struct proc *rp;
  register int i, j;
  static int bss_test;

  /* bss sanity check */
  assert(bss_test == 0);
  bss_test = 1;

  /* save a global copy of the boot parameters */
  memcpy(&kinfo, local_cbi, sizeof(kinfo));
  memcpy(&kmess, kinfo.kmess, sizeof(kmess));

  machine.board_id = get_board_id_by_name(env_get(BOARDVARNAME));

#ifdef __arm__
  arch_ser_init();
#endif

  DEBUGBASIC(("MINIX booting\n"));
  kernel_may_alloc = 1;

  assert(sizeof(kinfo.boot_procs) == sizeof(image));
  memcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs));

  cstart();           /* CPU initialization */
  BKL_LOCK();

  DEBUGEXTRA(("main()\n"));

  proc_init();        /* Process table setup */
  IPCF_POOL_INIT();   /* IPC filter pool */

  if(NR_BOOT_MODULES != kinfo.mbi.mi_mods_count)
    panic("expecting %d boot processes/modules, found %d",
          NR_BOOT_MODULES, kinfo.mbi.mi_mods_count);

  /* Set up proc table entries for processes in boot image. */
  for (i=0; i < NR_BOOT_PROCS; ++i) {
    int schedulable_proc;
    proc_nr_t proc_nr;
    int ipc_to_m, kcalls;
    sys_map_t map;

    ip = &image[i];             /* process' attributes */
    rp = proc_addr(ip->proc_nr);
    ip->endpoint = rp->p_endpoint;
    rp->p_cpu_time_left = 0;

    if(i < NR_TASKS) {
      strlcpy(rp->p_name, ip->proc_name, sizeof(rp->p_name));
    }

    if(i >= NR_TASKS) {
      multiboot_module_t *mb_mod = &kinfo.module_list[i - NR_TASKS];
      ip->start_addr = mb_mod->mod_start;
      ip->len = mb_mod->mod_end - mb_mod->mod_start;
    }

    reset_proc_accounting(rp);

    /* Determine if process is immediately schedulable */
    proc_nr = proc_nr(rp);
    schedulable_proc = (iskerneln(proc_nr) || isrootsysn(proc_nr) ||
                       proc_nr == VM_PROC_NR);

    if(schedulable_proc) {
      get_priv(rp, static_priv_id(proc_nr));
      /* ... privilege setup ... */
    } else {
      RTS_SET(rp, RTS_NO_PRIV | RTS_NO_QUANTUM);
    }

    arch_boot_proc(ip, rp);

    if(!get_cpulocal_var(proc_ptr))
      get_cpulocal_var(proc_ptr) = rp;

    if(rp->p_nr != VM_PROC_NR && rp->p_nr >= 0) {
      rp->p_rts_flags |= RTS_VMINHIBIT;
      rp->p_rts_flags |= RTS_BOOTINHIBIT;
    }

    rp->p_rts_flags |= RTS_PROC_STOP;
    rp->p_rts_flags &= ~RTS_SLOT_FREE;
  }

  /* update boot procs info for VM */
  memcpy(kinfo.boot_procs, image, sizeof(kinfo.boot_procs));

  arch_post_init();

  /* Initialize kernel call names */
  IPCNAME(SEND);
  IPCNAME(RECEIVE);
  IPCNAME(SENDREC);
  /* ... more call names ... */

  /* System initialization */
  memory_init();
  DEBUGEXTRA(("system_init()... "));
  system_init();
  DEBUGEXTRA(("done\n"));

  /* The bootstrap phase is over */
  /* ... transition to scheduler ... */
}
\end{lstlisting}

\subsubsection{BSS Sanity Check}

\how{
\begin{enumerate}
\item \textbf{Mechanism}: Static variable bss\_test declared at function scope
\item \textbf{Assertion}: assert(bss\_test == 0)
  \begin{enumerate}
    \item Before kernel boot, linker ensures all BSS (uninitialized) data is zeroed by bootloader
    \item If bss\_test != 0, bootloader failed to zero BSS section
    \item Subsequent code sets bss\_test = 1 for next run
  \end{enumerate}
\item \textbf{CPU Effect}: None (pure assertion)
\item \textbf{Timing}: 1-2 CPU cycles (compare and branch)
\end{enumerate}
}

\subsubsection{cstart(): Architecture-Specific CPU Setup}

\how{
\begin{enumerate}
\item \textbf{Purpose}: Initialize CPU descriptor tables and mode settings
\item \textbf{On i386}: Called from main.c line 145
  \begin{enumerate}
    \item Load GDT (Global Descriptor Table)
    \item Load IDT (Interrupt Descriptor Table)
    \item Load TSS (Task State Segment) for task switching
    \item Set up segment registers (CS, DS, SS)
    \item Enable CPU features (FPU, SSE, if present)
  \end{enumerate}
\item \textbf{Register Effects}:
  \begin{verbatim}
  GDTR <- physical address and size of GDT
  IDTR <- physical address and size of IDT
  TR <- TSS selector
  CR4 <- (enable features like SSE, if supported)
  \end{verbatim}
\item \textbf{Return}: Function returns after tables loaded and CPU ready
\item \textbf{Timing}: 10-20ms (depends on feature detection, FPU setup)
\end{enumerate}
}

\subsubsection{proc\_init(): Process Table Initialization}

\how{
\begin{enumerate}
\item \textbf{Purpose}: Prepare the process array for operation
\item \textbf{Operation}:
  \begin{enumerate}
    \item Iterate through process table (NR\_PROCS entries)
    \item For each entry: zero the proc struct, initialize lock fields, set flags
    \item Set proc\_ptr (current process) to NULL
  \end{enumerate}
\item \textbf{Memory Setup}:
  \begin{verbatim}
  Process table is kernel BSS array, pre-allocated at compile time.
  Each entry: ~200-300 bytes (proc structure with nested fields)
  Total: NR_PROCS * sizeof(struct proc)
  \end{verbatim}
\item \textbf{Timing}: 1-2ms (memory initialization for ~100-150 process slots)
\end{enumerate}
}

\subsubsection{Boot Process Loop: per-process Initialization}

\how{
\begin{enumerate}
\item \textbf{Iteration}: for (i=0; i < NR\_BOOT\_PROCS; ++i)
  \begin{enumerate}
    \item NR\_BOOT\_PROCS = NR\_TASKS (kernel tasks) + NR\_SYS\_PROCS (system processes)
    \item Typical count: 12-15 processes (kernel tasks + filesystem + network + device drivers)
  \end{enumerate}
\item \textbf{Per-Process Setup}:
  \begin{enumerate}
    \item Assign process number and endpoint ID
    \item Copy process name (if task) or extract multiboot module info
    \item Reset CPU time accounting
    \item Determine if process is immediately schedulable
    \item Assign security privileges (via get\_priv)
    \item Call arch\_boot\_proc for architecture-specific setup
  \end{enumerate}
\item \textbf{Scheduling Flags}:
  \begin{enumerate}
    \item Schedulable processes (kernel tasks, VM, root system): RTS\_NO\_PRIV = 0
    \item Non-schedulable processes: RTS\_NO\_PRIV | RTS\_NO\_QUANTUM set
    \item All processes: RTS\_PROC\_STOP set (inhibit until ready)
  \end{enumerate}
\item \textbf{Timing}: 5-10ms for all processes (0.3-1ms per process, 12-15 iterations)
\end{enumerate}
}

\subsubsection{memory\_init(): Memory Management Setup}

\how{
\begin{enumerate}
\item \textbf{Purpose}: Initialize virtual memory and paging subsystem
\item \textbf{Operation}:
  \begin{enumerate}
    \item Initialize page frame allocator
    \item Set up virtual address space layout for kernel
    \item Initialize memory pool structures
    \item Prepare VM server process (already a kernel process at this point)
  \end{enumerate}
\item \textbf{Effect}: After memory\_init(), virtual memory is operational
\item \textbf{Timing}: 15-25ms (page frame bitmap initialization, pool setup)
\end{enumerate}
}

\subsubsection{system\_init(): System-wide Initialization}

\how{
\begin{enumerate}
\item \textbf{Purpose}: Install exception handlers, set up IRQ routing, initialize syscall dispatcher
\item \textbf{Operation}:
  \begin{enumerate}
    \item Install CPU exception handlers (page fault, divide by zero, etc.)
    \item Install interrupt handlers (timer, keyboard, network, etc.)
    \item Initialize syscall dispatcher (INT 80h entry point)
    \item Set up IPC message queues
  \end{enumerate}
\item \textbf{Timing}: 5-10ms (table initialization, handler registration)
\end{enumerate}
}

\section{Call Graph and Dependencies}

The kmain() execution follows a strict linear sequence:

\begin{verbatim}
kmain()
  |-> BSS Sanity Check
  |-> Copy boot parameters
  |-> cstart() [CPU initialization]
  |-> proc_init() [Process table]
  |-> Boot Process Loop [Initialize 12-15 processes]
  |-> memory_init() [Virtual memory setup]
  |-> system_init() [Exception/interrupt handlers]
  |-> Scheduler [Begin multitasking]
\end{verbatim}

\section{Critical Path Analysis}

The \textbf{critical path} (longest dependency chain) through kmain() is:

\begin{verbatim}
BSS Check -> Copy kinfo -> cstart() -> proc_init() ->
Boot Loop (per-process) -> memory_init() -> system_init() ->
Scheduler startup
\end{verbatim}

\textbf{Critical path length}: 35-65ms (total from kmain entry to scheduler ready)

This is the minimum boot time for MINIX kernel initialization. Additional time comes from:
\begin{itemize}
\item User-space server startup (filesystem, network drivers)
\item Application initialization
\item Disk I/O (loading drivers, filesystem tables)
\end{itemize}

\section{Transition: From kmain() to Scheduler}

At the end of \texttt{kmain()}, before function return:

\begin{enumerate}
\item \textbf{Timer Interrupt}: Install periodic timer interrupt (typically 10ms quantum)
\item \textbf{Scheduler Activation}: Set \texttt{proc\_ptr} to first schedulable process
\item \textbf{Context Switch}: Jump to first user-space process (e.g., filesystem server)
\item \textbf{Control Return}: Never returns to kmain(); kernel enters scheduler loop
\end{enumerate}

At this point, the kernel boot is complete, and the system is fully operational.

\section{Summary: kmain() Responsibilities}

\begin{enumerate}
\item \textbf{Validation}: Verify boot parameters and BSS initialization
\item \textbf{CPU Setup}: Install descriptor tables, configure CPU modes
\item \textbf{Process Management}: Initialize process table, load boot processes
\item \textbf{System Setup}: Install exception and interrupt handlers
\item \textbf{Memory Management}: Initialize virtual memory and paging
\item \textbf{Scheduler Activation}: Install timer and begin scheduling
\item \textbf{Orchestration}: Maintain initialization order and dependencies
\end{enumerate}

The completion of kmain() marks the transition from sequential boot code to concurrent
multitasking, with the kernel scheduler taking control.
