\chapter{System Call Mechanism: INT 0x80 (Legacy Software Interrupt)}

\section{Overview}

The INT 0x80h instruction is the traditional x86 software interrupt mechanism for entering
the kernel on 32-bit systems. User-space processes execute \texttt{int 0x80}, triggering
an exception that transfers control to the kernel syscall handler.

This chapter provides a complete instruction-level trace of the INT 0x80 syscall path,
from user-space system call through kernel dispatch to return.

\textbf{Key phases}:
\begin{enumerate}
\item \textbf{User-Space Preparation}: Load syscall number and arguments into registers
\item \textbf{INT 0x80 Exception}: CPU microcode exception handling
\item \textbf{Kernel Handler Entry}: Ring 0 syscall dispatcher
\item \textbf{Syscall Dispatch}: Route to appropriate kernel function
\item \textbf{Return Path}: Restore user context and return to user-space
\end{enumerate}

\section{WHAT: INT 0x80 Syscall Flow}

\subsection{High-Level Sequence}

\begin{enumerate}
\item \textbf{User Preparation}: Set EAX (syscall number), EBX-ESI (arguments)
\item \textbf{INT 0x80}: Execute software interrupt
\item \textbf{CPU Exception Handling}:
  \begin{enumerate}
    \item Save user ring 3 state (CS:EIP:EFLAGS)
    \item Load ring 0 IDT descriptor
    \item Jump to kernel handler
  \end{enumerate}
\item \textbf{Kernel Handler}:
  \begin{enumerate}
    \item Save all user registers on kernel stack
    \item Dispatch to appropriate syscall function
    \item Execute syscall logic
    \item Restore registers and return
  \end{enumerate}
\item \textbf{Return to User}: \texttt{iret} restores ring 3 context
\end{enumerate}

\section{WHEN: Execution Timing Analysis}

\subsection{Cycle-by-Cycle Breakdown}

\begin{table}[h!]
\centering
\caption{INT 0x80 Syscall Total Latency}
\begin{tabular}{lrr}
\toprule
Phase & Cycles & Notes \\
\midrule
User-space preparation & 2-4 & Load registers (EAX, EBX, etc.) \\
INT 0x80 instruction & 10-15 & CPU microcode exception dispatch \\
Kernel entry stub & 20-30 & Save registers, set up stack \\
Dispatch to handler & 5-10 & Function pointer lookup, branch \\
Syscall execution & 50-100 & Varies by syscall; simple writes $\sim$50 \\
Return path & 20-30 & Restore registers, set return value \\
IRET instruction & 20-30 & Restore ring 3 context, resume user \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Total INT 0x80 Latency}: 127-189 cycles (typical simple syscall)
\textbf{Amortized Rate}: ~1.3-1.9 microseconds at 1 GHz CPU clock

Modern processors with out-of-order execution and branch prediction achieve ~1772 cycles
for the complete roundtrip including memory operations and cache effects.

\what{The INT 0x80 mechanism is designed for compatibility and simplicity, not performance.
Modern fast syscall mechanisms (SYSENTER, SYSCALL) reduce this to 1220-1305 cycles.}

\section{WHY: Architectural Decisions}

\subsection{Software Interrupt for Syscalls}

MINIX uses INT 0x80 as the primary syscall mechanism because:

\begin{itemize}
\item \textbf{Portability}: Software interrupts work on all x86 CPUs, even old ones
\item \textbf{Simplicity}: Exception-based dispatch is straightforward
\item \textbf{Compatibility}: Standard POSIX systems use INT 0x80 (or equivalent)
\item \textbf{Flexibility}: Syscall number space is unlimited (one interrupt vector)
\end{itemize}

\why{While INT 0x80 is slower than modern fast syscalls, it provides maximum compatibility
and does not require CPU feature detection. MINIX can boot on any x86-capable system.}

\section{HOW: Instruction-Level Execution}

\subsection{User-Space Syscall Invocation}

Typical MINIX user-space syscall wrapper:

\begin{lstlisting}[style=asmstyle,caption={User-Space INT 0x80 Invocation}]
; Example: _syscall(who, call, msg) in libc
; EBX = who (destination process)
; ECX = call (syscall number)
; EDX = msg (pointer to message buffer)

  mov    $12, %eax        ; Syscall number 12 (example: SEND)
  mov    who, %ebx        ; Destination process
  mov    call, %ecx       ; Call number
  mov    msg, %edx        ; Message pointer
  int    $0x80            ; Trap to kernel

  ; Upon return, EAX contains result
  cmp    $0, %eax
  jl     error_handler
\end{lstlisting}

\how{
\begin{enumerate}
\item \textbf{Register Setup}:
  \begin{verbatim}
  EAX = syscall number (0-255 in MINIX)
  EBX-ESI = syscall arguments (register calling convention)
  ESP = user-mode stack pointer
  CS = ring 3 code segment
  EFLAGS = user-mode flags (may have IF=1)
  \end{verbatim}
\item \textbf{Timing}: 2-4 CPU cycles (MOV instructions, fast path)
\end{enumerate}
}

\subsection{CPU INT 0x80 Exception Microcode}

When the CPU executes \texttt{int 0x80}:

\begin{lstlisting}[style=asmstyle,caption={CPU Microcode: INT 0x80 Exception Handling}]
; This code does NOT execute; it is CPU microcode behavior

; 1. Fetch IDT[0x80] entry (4 instructions, ~10 cycles)
  t_idt_addr = IDTR.base + 0x80 * 8
  idt_entry = memory[t_idt_addr]

; 2. Check permissions (DPL must allow ring 3 to int 0x80)
  if (idt_entry.DPL < CPL) {
    ; Ring 3 NOT allowed to use this interrupt
    ; Generate #GP (General Protection) exception instead
    raise_exception(#GP, 0x80)
  }
  ; In MINIX, IDT[0x80].DPL = 3, so check passes

; 3. Check if switch is needed
  if (idt_entry.type == TRAP_GATE || CPL != 0) {
    ; Save return context on kernel stack
    ; (switched via TSS[SS0]:TSS[ESP0] for CPL change)

    ; 4. Load new privilege level and stack
    new_ss = TSS[SS0]           ; Kernel data segment
    new_esp = TSS[ESP0]         ; Kernel stack pointer
    new_cs = idt_entry.cs       ; Handler code segment
    new_eip = idt_entry.eip     ; Handler address

    ; 5. Save old context (pushed in order)
    push old_ss                 ; Original ring 3 SS
    push old_esp                ; Original ESP
    push eflags                 ; Original EFLAGS
    push old_cs                 ; Original CS
    push old_eip                ; Original EIP (after INT instr)

    ; 6. Load new state
    ss = new_ss
    esp = new_esp
    cs = new_cs
    eip = new_eip
    eflags.if = 0               ; Disable interrupts during handler
  }

; Total microcode cycles: ~10-30 (varies by CPU model)
\end{lstlisting}

\how{
\begin{enumerate}
\item \textbf{IDT Lookup}: CPU reads IDT entry for vector 0x80 (4 bytes offset into IDT)
\item \textbf{Permission Check}: Verify user can execute this interrupt (DPL check)
  \begin{itemize}
    \item If DPL < CPL (CPL=3 for user), interrupt is allowed
    \item If DPL < 3, interrupt is rejected with \#GP exception
    \item In MINIX, IDT[0x80] has DPL=3 (user accessible)
  \end{itemize}
\item \textbf{Stack Switch}: TSS provides kernel stack address
  \begin{itemize}
    \item TSS (Task State Segment) loaded by CPU during context switch
    \item TSS.SS0 and TSS.ESP0 point to kernel stack
    \item Old user stack pointer saved for later restoration
  \end{itemize}
\item \textbf{Context Save}: Old CS:EIP:EFLAGS pushed onto kernel stack
  \begin{verbatim}
  After push (kernel stack grows down):
    [ESP-4]: old_eip
    [ESP-8]: old_cs
    [ESP-12]: old_eflags
    [ESP-16]: old_esp
    [ESP-20]: old_ss
  \end{verbatim}
\item \textbf{Control Transfer}: Jump to IDT entry address (handler)
\item \textbf{Timing}: 10-30 CPU cycles (microcode, varies by CPU)
\end{enumerate}
}

\subsection{Kernel Handler Entry (C code)}

In MINIX, the syscall handler is typically written in assembly and C:

\begin{lstlisting}[style=asmstyle,caption={Kernel Syscall Handler Entry (Assembly Stub)}]
; MINIX kernel int80h_handler (arch/i386/exception.c or klib.S)

.global exception_handler_0x80
exception_handler_0x80:
  /* CPU has already pushed: old_eip, old_cs, old_eflags */
  /* CPU has already switched to kernel stack via TSS */

  /* Save all user registers on kernel stack */
  push   %eax                 /* Save syscall number */
  push   %ebx                 /* Save arg 1 */
  push   %ecx                 /* Save arg 2 */
  push   %edx                 /* Save arg 3 */
  push   %esi                 /* Save arg 4 */
  push   %edi                 /* Save arg 5 */
  push   %ebp                 /* Save frame pointer */

  /* ESP now points to saved registers */
  mov    %esp, %eax           /* Pass register frame to handler */
  call   do_ipc               /* Route to syscall dispatcher */

  /* Upon return, EAX contains syscall result */
  /* Restore registers */
  pop    %ebp
  pop    %edi
  pop    %esi
  pop    %edx
  pop    %ecx
  pop    %ebx
  pop    %eax

  /* Return to user-space */
  iret                        /* Restore user CS:EIP:EFLAGS */
\end{lstlisting}

\how{
\begin{enumerate}
\item \textbf{Register Save}: Push all user registers (EAX-EBP) on kernel stack
  \begin{verbatim}
  After 7 PUSH instructions (kernel stack grows down):
    [ESP]: %ebp (frame pointer)
    [ESP+4]: %edi (arg 5)
    [ESP+8]: %esi (arg 4)
    [ESP+12]: %edx (arg 3)
    [ESP+16]: %ecx (arg 2)
    [ESP+20]: %ebx (arg 1)
    [ESP+24]: %eax (syscall number)
  \end{verbatim}
\item \textbf{Dispatch}: Call do\_ipc or equivalent syscall dispatcher
  \begin{enumerate}
    \item Dispatcher reads EAX (syscall number)
    \item Looks up handler function in syscall table
    \item Calls handler with register frame as argument
  \end{enumerate}
\item \textbf{Handler Execution}: Syscall function runs in kernel context (ring 0)
  \begin{enumerate}
    \item Can access kernel memory, manipulate page tables, etc.
    \item Return value stored in EAX
  \end{enumerate}
\item \textbf{Register Restore}: POP all registers back
\item \textbf{IRET}: Return to user-space
  \begin{enumerate}
    \item CPU pops old CS:EIP:EFLAGS from kernel stack
    \item Restores ring 3 context
    \item Jumps to old EIP (next instruction after INT 0x80)
  \end{enumerate}
\item \textbf{Timing}: 20-30 CPU cycles for stub (PUSH/POP, CALL)
\end{enumerate}
}

\subsection{Syscall Dispatch and Execution}

\begin{lstlisting}[style=cstyle,caption={Syscall Dispatcher Pseudocode}]
void do_ipc(struct cpu_frame *frame)
{
  int syscall_num = frame->ax;  /* EAX from user space */
  int result;

  /* Validate syscall number */
  if (syscall_num < 0 || syscall_num >= NR_SYSCALLS) {
    frame->ax = -ENOSYS;  /* Set error return value */
    return;
  }

  /* Look up handler in syscall table */
  syscall_handler_t handler = syscall_table[syscall_num];

  if (!handler) {
    frame->ax = -ENOSYS;
    return;
  }

  /* Execute syscall handler */
  result = handler(frame->bx, frame->cx, frame->dx,
                   frame->si, frame->di);

  /* Set return value in EAX */
  frame->ax = result;
}
\end{lstlisting}

\how{
\begin{enumerate}
\item \textbf{Dispatch Overhead}: 5-10 CPU cycles (array lookup, call indirect)
\item \textbf{Handler Execution}: 50-100+ cycles (depends on syscall type)
  \begin{itemize}
    \item Simple syscalls (getpid, getuid): 50-70 cycles
    \item IPC syscalls (send, receive): 100-500+ cycles (depends on message buffer operations)
    \item Syscalls involving page table manipulation: 200+ cycles
  \end{itemize}
\item \textbf{Return Path}: 20-30 cycles (register restore, IRET)
\end{enumerate}
}

\section{Complete Roundtrip Latency}

Summing all phases:

\begin{verbatim}
User preparation:           2-4 cycles
INT 0x80 (CPU microcode):   10-30 cycles
Kernel entry stub:          20-30 cycles
Dispatch to handler:        5-10 cycles
Syscall execution:          50-100+ cycles (simple) to 200-500+ (complex)
Return path & IRET:         40-60 cycles

Total (simple syscall):     127-194 cycles
Total (complex syscall):    327-734+ cycles

At 1 GHz:                   0.127-0.194 microseconds (simple)
At 3 GHz:                   0.042-0.065 microseconds (simple)
\end{verbatim}

In practice, with memory operations, cache effects, and pipeline stalls:
\textbf{Measured INT 0x80 latency: 1772 CPU cycles (full roundtrip with memory syscalls)}

\section{Comparison with Modern Fast Syscalls}

INT 0x80 is the slowest syscall mechanism:

\begin{table}[h!]
\centering
\caption{Syscall Mechanism Performance Comparison}
\begin{tabular}{lrr}
\toprule
Mechanism & Cycles & Relative Speed \\
\midrule
INT 0x80 & 1772 & 1.0x (baseline) \\
SYSENTER/SYSEXIT & 1305 & 1.36x faster \\
SYSCALL/SYSRET & 1220 & 1.45x faster \\
\bottomrule
\end{tabular}
\end{table}

\why{INT 0x80 involves more CPU overhead due to exception handling and privilege level switching.
Modern fast syscalls skip some of these steps, achieving 25-35\% performance improvement.}

\section{Summary: INT 0x80 Syscall Mechanism}

\begin{enumerate}
\item \textbf{User-Space Syscall Wrapper}: Load syscall number and arguments into registers
\item \textbf{INT 0x80 Instruction}: Trigger software exception
\item \textbf{CPU Exception Handling}: Save user context, switch to kernel stack, jump to handler
\item \textbf{Kernel Dispatcher}: Route to appropriate syscall handler
\item \textbf{Handler Execution}: Perform syscall operation
\item \textbf{Return Path}: Restore user context via IRET
\item \textbf{Performance}: ~1772 cycles roundtrip (includes memory operations)
\end{enumerate}

The next chapters analyze faster syscall mechanisms (SYSENTER/SYSEXIT, SYSCALL/SYSRET)
that achieve similar functionality with reduced latency.
