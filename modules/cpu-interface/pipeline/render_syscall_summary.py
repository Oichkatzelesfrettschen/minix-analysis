#!/usr/bin/env python3
"""
Quick summaries for CPU syscall catalogue data.
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, Dict, List


def load_kernel_structure(path: Path) -> Dict[str, Any]:
    """Load kernel_structure JSON exported by the analysis pipeline."""
    if not path.exists():
        raise FileNotFoundError(f"Kernel structure JSON not found: {path}")
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def summarise_syscalls(data: Dict[str, Any], limit: int) -> Dict[str, Any]:
    """Produce a compact summary of syscall statistics."""
    syscalls: List[Dict[str, Any]] = data.get("system_calls", [])
    sorted_syscalls = sorted(
        syscalls,
        key=lambda entry: entry.get("line_count", 0),
        reverse=True,
    )
    top = [
        {
            "name": entry.get("name"),
            "file": entry.get("file"),
            "line_count": entry.get("line_count"),
        }
        for entry in sorted_syscalls[:limit]
    ]
    return {
        "syscall_count": len(syscalls),
        "top_syscalls": top,
    }


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Render a concise summary of the MINIX syscall catalogue using "
            "the kernel_structure.json generated by the analysis pipeline."
        )
    )
    parser.add_argument(
        "--kernel-structure",
        default="diagrams/data/kernel_structure.json",
        help="Path to kernel_structure.json (default: diagrams/data/kernel_structure.json)",
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=5,
        help="Number of top syscalls to include based on line count (default: 5)",
    )
    parser.add_argument(
        "--output",
        help="Optional file to write JSON summary to (defaults to stdout)",
    )
    args = parser.parse_args()

    data = load_kernel_structure(Path(args.kernel_structure))
    summary = summarise_syscalls(data, args.limit)

    output_json = json.dumps(summary, indent=2)
    if args.output:
        Path(args.output).write_text(output_json, encoding="utf-8")
    else:
        print(output_json)


if __name__ == "__main__":
    main()
